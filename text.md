# Лекция 3

### Многозадачность
Способность операционной системы выполнять несколько программ одновременно, то есть паралленьно.

Если аппаратная среда имеет возможность в один момент времени выполнять только 1 последовательность команд, а параллельное выполнение нескольких программ достингается за счет частого переключения контекста, то такая ситуация называется псевдопараллельная многозадачность.

Полноценная многозадачность может быть реализована только на соответсвующей аппаратуре.

### Виды многозадачности
* **Вытесняющая** - каждому процессу отводиться квант времени $\Delta t$ на выполенние, после истечения которого ОС прерывает выполнение процесса и запускает планирование.
* **Не вытесняющая** - процесс, выполняющийся самостоятельно решает отдавать управление ОС иил нет.

### Процесс
Программа и все необходимые ей данные на этапе исполнения в ОС.

Стандарт ISO 9000:2000 определяет процесс как совокупность взаимосвязанных и взяимодействующих действий, преобразующих входящие данные в исходящие.

### Блок управления процессом Process Control Block

Для того, чтобы операционная система могла выполнять операции над процессами, каждый процесс представляется в ней некоторой структурой данных.
Содержит информацию, специфическую для данного процесса

* состояние, в котором находится процесс
* программный счетчик процесса или, другими словами, адрес команды, которая должна быть выполнена для него следующей
* содержимое регистров процессора
* данные, необходимые для планирования использования процессора и управления памятью
* учетные данные
* сведения об усройствах ввода/вывода, связанных с процессором.

### Состояние процесса

* При рождении процесс получает в свое распоряжение **адресное пространство**, а которое загружается программный код процесса.
* Процессу выделяются **стек** и **системные ресурсы**, устанавливается начальное значение программного счетчика процесса и т.д. Родившийся процесс переводиться в состояние готовность. При завершении своей деятельности процесс из состояния исполнения попадает в состояние закончил исполнение
* В ОС состояния процесса могут быть еще более детализированы, могут появится некоторые новые варианты переходов из одного состояния в другое
* Так, например, модель состояний процессов для операционной системы Windows NT содержит 7 различных состояний, а для операционной системы Unix-9.

### Управление процессами

Процесс не может перейти из одного состояния в другое самостоятельно. Изменением состояния процессов занимается ОС, совевршая оперции над ними.

Операции можно объединить в три пары:

* **создание процесса - завершения процесса**
* **приостановка процесса - запуск процесса**
* **блокирование процесса - разблокирование процесса**

Операции создания и завершения процесса являются **одноразовыми**.

Все остальные операции, связанные с изменениями состояния прцессов, юудь то запуск или блокировка, как правило, являются **многоразовыми**.

### Рождение процессов

Любая ОС, поддерживающая концепцию *процессов*, обладает средствами для их *создания*. В очень простых системах все *процессы* могут быть порождены на этапе старта системы. Более сложные операционные системы создают *процессы* динамически, по мере необходимости.

Инициатором рождения нового процесса после старта операционной системы может выступить либо процесс пользователя, совершивший специальный системный вызов, либо сама операционная система, то есть, в конечном итоге, тоже некоторый процесс.

### Завершение процессов

После того как процесс завершил свою работу, ОС переводит его в состояние закончил исполнение и освобождает все ресурсы, делая соответствующие записи в блоке управления процессом

При этом сам PCB не уничтожается, а остается в системе еще некоторое время.

### Многоразовые операции

* Приостановление процесса
* Блокирование процесса
* Разблокирование процесса

**Приостановка процесса** - это результат внешнего воздействия.\
**Блокирование** - это результат внутреннего воздействия внутри процесса.

### Получение информации о процессе

Данные ядра, находящиеся в контексте ядра процесса, не могут быть прочитаны процессом непосредственно. Для получения информации о них, процесс должен совершить соответствующий системный вызов.\
    *getpid()* - значение id текщего процесса \
    *getppid()* -значение id родительского процесса

\#include \<sys/types.h\>\
\#include <unistd.h>


### Системные вызовы создания процесса
* id процесса
* id родтельского процесса
* время, оставшееся до получения сигнала SIGALRM
* сигналы, ожидавшие доставки род. процессу
* не будут доставляться порожденному процессу.


**fork()** служит для создания нового процесса в ОС UNIX.

Тот кто вызвал **fork()** - родительский процесс.

### Системный вызов fork()

При однократном системном вызове возврат из него может произойти дважды: один раз в родительском процессе, а второй раз в порожденном процессе.
Для того, чтобы после возвращения из системного вызова fork() процессы могли определить, какой из них является дочерним, а какой родительским, и, соответсвтенно, по-разному организовать свое поведение.\
Если fork() вернула 0 - то это дочерний процесс
Если fork() вернула что-то другое, что это родительский процесс.

## ДЗ - Лабу 1
Программа, которая из род процесса создает дочерний
Дочерний процесс генерит 10 МБ хери и пишет на диск
Внутри файла - я какой-то процесс и 10МБ хери
Родитель ждет через waitpid() после чего выводит время исполнения дочернего процесса.
