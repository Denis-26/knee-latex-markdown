<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/css/latex-style.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="лекция-3">Лекция 3</h1>
<h3 id="многозадачность">Многозадачность</h3>
<p>Способность операционной системы выполнять несколько программ одновременно, то есть паралленьно.</p>
<p>Если аппаратная среда имеет возможность в один момент времени выполнять только 1 последовательность команд, а параллельное выполнение нескольких программ достингается за счет частого переключения контекста, то такая ситуация называется псевдопараллельная многозадачность.</p>
<p>Полноценная многозадачность может быть реализована только на соответсвующей аппаратуре.</p>
<h3 id="виды-многозадачности">Виды многозадачности</h3>
<ul>
<li><strong>Вытесняющая</strong> - каждому процессу отводиться квант времени <span class="math inline">\(\Delta t\)</span> на выполенние, после истечения которого ОС прерывает выполнение процесса и запускает планирование.</li>
<li><strong>Не вытесняющая</strong> - процесс, выполняющийся самостоятельно решает отдавать управление ОС иил нет.</li>
</ul>
<h3 id="процесс">Процесс</h3>
<p>Программа и все необходимые ей данные на этапе исполнения в ОС.</p>
<p>Стандарт ISO 9000:2000 определяет процесс как совокупность взаимосвязанных и взяимодействующих действий, преобразующих входящие данные в исходящие.</p>
<h3 id="блок-управления-процессом-process-control-block">Блок управления процессом Process Control Block</h3>
<p>Для того, чтобы операционная система могла выполнять операции над процессами, каждый процесс представляется в ней некоторой структурой данных. Содержит информацию, специфическую для данного процесса</p>
<ul>
<li>состояние, в котором находится процесс</li>
<li>программный счетчик процесса или, другими словами, адрес команды, которая должна быть выполнена для него следующей</li>
<li>содержимое регистров процессора</li>
<li>данные, необходимые для планирования использования процессора и управления памятью</li>
<li>учетные данные</li>
<li>сведения об усройствах ввода/вывода, связанных с процессором.</li>
</ul>
<h3 id="состояние-процесса">Состояние процесса</h3>
<ul>
<li>При рождении процесс получает в свое распоряжение <strong>адресное пространство</strong>, а которое загружается программный код процесса.</li>
<li>Процессу выделяются <strong>стек</strong> и <strong>системные ресурсы</strong>, устанавливается начальное значение программного счетчика процесса и т.д. Родившийся процесс переводиться в состояние готовность. При завершении своей деятельности процесс из состояния исполнения попадает в состояние закончил исполнение</li>
<li>В ОС состояния процесса могут быть еще более детализированы, могут появится некоторые новые варианты переходов из одного состояния в другое</li>
<li>Так, например, модель состояний процессов для операционной системы Windows NT содержит 7 различных состояний, а для операционной системы Unix-9.</li>
</ul>
<h3 id="управление-процессами">Управление процессами</h3>
<p>Процесс не может перейти из одного состояния в другое самостоятельно. Изменением состояния процессов занимается ОС, совевршая оперции над ними.</p>
<p>Операции можно объединить в три пары:</p>
<ul>
<li><strong>создание процесса - завершения процесса</strong></li>
<li><strong>приостановка процесса - запуск процесса</strong></li>
<li><strong>блокирование процесса - разблокирование процесса</strong></li>
</ul>
<p>Операции создания и завершения процесса являются <strong>одноразовыми</strong>.</p>
<p>Все остальные операции, связанные с изменениями состояния прцессов, юудь то запуск или блокировка, как правило, являются <strong>многоразовыми</strong>.</p>
<h3 id="рождение-процессов">Рождение процессов</h3>
<p>Любая ОС, поддерживающая концепцию <em>процессов</em>, обладает средствами для их <em>создания</em>. В очень простых системах все <em>процессы</em> могут быть порождены на этапе старта системы. Более сложные операционные системы создают <em>процессы</em> динамически, по мере необходимости.</p>
<p>Инициатором рождения нового процесса после старта операционной системы может выступить либо процесс пользователя, совершивший специальный системный вызов, либо сама операционная система, то есть, в конечном итоге, тоже некоторый процесс.</p>
<h3 id="завершение-процессов">Завершение процессов</h3>
<p>После того как процесс завершил свою работу, ОС переводит его в состояние закончил исполнение и освобождает все ресурсы, делая соответствующие записи в блоке управления процессом</p>
<p>При этом сам PCB не уничтожается, а остается в системе еще некоторое время.</p>
<h3 id="многоразовые-операции">Многоразовые операции</h3>
<ul>
<li>Приостановление процесса</li>
<li>Блокирование процесса</li>
<li>Разблокирование процесса</li>
</ul>
<p><strong>Приостановка процесса</strong> - это результат внешнего воздействия.<br />
<strong>Блокирование</strong> - это результат внутреннего воздействия внутри процесса.</p>
<h3 id="получение-информации-о-процессе">Получение информации о процессе</h3>
<p>Данные ядра, находящиеся в контексте ядра процесса, не могут быть прочитаны процессом непосредственно. Для получения информации о них, процесс должен совершить соответствующий системный вызов.<br />
<em>getpid()</em> - значение id текщего процесса<br />
<em>getppid()</em> -значение id родительского процесса</p>
<p>#include &lt;sys/types.h&gt;<br />
#include &lt;unistd.h&gt;</p>
<h3 id="системные-вызовы-создания-процесса">Системные вызовы создания процесса</h3>
<ul>
<li>id процесса</li>
<li>id родтельского процесса</li>
<li>время, оставшееся до получения сигнала SIGALRM</li>
<li>сигналы, ожидавшие доставки род. процессу</li>
<li>не будут доставляться порожденному процессу.</li>
</ul>
<p><strong>fork()</strong> служит для создания нового процесса в ОС UNIX.</p>
<p>Тот кто вызвал <strong>fork()</strong> - родительский процесс.</p>
<h3 id="системный-вызов-fork">Системный вызов fork()</h3>
<p>При однократном системном вызове возврат из него может произойти дважды: один раз в родительском процессе, а второй раз в порожденном процессе. Для того, чтобы после возвращения из системного вызова fork() процессы могли определить, какой из них является дочерним, а какой родительским, и, соответсвтенно, по-разному организовать свое поведение.<br />
Если fork() вернула 0 - то это дочерний процесс Если fork() вернула что-то другое, что это родительский процесс.</p>
<h2 id="дз---лабу-1">ДЗ - Лабу 1</h2>
<p>Программа, которая из род процесса создает дочерний Дочерний процесс генерит 10 МБ хери и пишет на диск Внутри файла - я какой-то процесс и 10МБ хери Родитель ждет через waitpid() после чего выводит время исполнения дочернего процесса.</p>
</body>
</html>
